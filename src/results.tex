% -*- root: ../main.tex -*-
\chapter{Results\label{chap:results}}

\paragraph{Abstract}
% In this chapter we will expose the structure of the generated proofs. We will mention some of the most relevant and difficult intermediate steps that we needed to prove.

%Finally, the we will compare the timings of using automatic theorem provers versus model searching done by \citetool{leap}.

\section{Axioms}

The set of relevant axioms needed to prove all the invariants is presented now.
%
There are a lot of secondary axioms needed by \spass that have been omitted. 
%
The omitted axioms refer: 
%
to the sorting (\spass is not multi-sorted as the theory we work with. It is necessary to define that an \addr is not an \elem, an \elem is not an \addr, etc), to constants (\spass does not include arithmetic, so $0$,$1$,... must be defined as unique 0-ary functions specifying that $0\not\eq 1,0\not\eq 2$,...); 
%
to the local and global variables of the program (\leap is quantifier free but \spass need to quantify every variable)
%
The set of axioms has been divided in 9 groups. 
%
This division 
		
\label{ax::fulllist}
\input{src/axioms}


The full list of axioms has been included as an appendix at \ref{spass:syntax_file}. 

%

We claim that there is no need of more axioms than the ones defined at \ref{ax::fulllist}. 
%
The next section will present which axioms are needed for which invariants.

\section{Analysis of generated proofs}
\label{proof:Preserve}
\label{sec:axiomgraph}

\paragraph{Example}
Lets take \invDisjoint as an example because its simplicity.
%
To prove \invDisjoint valid
%
(\footnote{Its full definition is at \ref{inv::full:disjoint}})
%
there are only needed 3 axioms: the axiom which states that numbers are different and the 2 axioms which states $i$ and $j$ are threads. 
%
With this 3 axiom, \spass can prove valid all the \spass problems associated with \invDisjoint.


To clarify the process described \doubt{in/at} \ref{ProcessDescription} we expose all the \spass problems generated to prove \invDisjoint.
%
There are 362 \spass problems. Half of them correspond to the \reducedProblem and the other half to the \smallToBig problem.
%
For each half, there are 181 \spass problems:
%
For \textbf{\instantiation} there is one problem. 
%
For self-consecution there are 60 \spass problems (the program has 55 lines, so there is a \gls{VC} for each line except for \textit{while} and \textit{if} which have 2 \gls{VC} associated depending on the validity of the condition. As there are 3 while and 2 if, we have) for each thread. 
%
As \invDisjoint involves 2 threads, there are \textbf{120 self-consecution \spass problems}.
%
Finally for \textbf{Others consecution} there are \textbf{60} \spass problems.

\paragraph{Analysis}

Most of the transitions (\numTransitionsProvedWithPC in \numTotalTransitions) are proven without any relevant axiom. 
%
Some of them don't even need any axiom. 
%
\smallToBig problems usually don't need any axiom, because there are simple but big \gls{FOL} formulas.

Table \ref{table:analysisProofs}  contains some global information about the prove of each invariant.
%
It is important to mention that every invariant has 2 problems of \instantiation. 

\begin{table}[hbtp]
\centering
\begin{tabular}{ccccc}
Invariant & Self-consecution & Others consecution & Total & Number of axioms used\\
\input{src/tex/analysisTable.tex}
\end{tabular}
\label{table:analysisProofs}
\caption{Global statistics of each invariant.}
\end{table}


In terms of number of axioms, it is interesting to see that \_\_\_\_\_\_\_\_ is the most complicated, followed by \_\_\_\_\_\_\_\_. 
%
The differences on the number of other-consecution problem is caused by the splitting on complex \spass problems. 
%
To prove \invOrder all other-consecution problems have been splat, but for \invLock and \invNext just 21 other consecution problems have been splat.
%
Despite that fact, \invOrder is not very complex in terms of number of axioms. 


\subsection{Special transitions}

Due to the limited space, we just present the deep analysis of some important transitions.

The offending transitions of \invPreserve are $35$ and $51$, the ones where the list is really modified while inserting and removing, respectively.
%
All the other transitions generate simple \spass problem which are proven easily.
%
For this two special transition some expert knowledge had been needed, because of some limitation \spass has.
%
This limitation is that \spass does not know how to choose the axioms to use, leading into an unnecessary branch of the proof. 
%
If \spass could know that, it would be much more efficient. 
%
On the other side, the great advantage of \spass is its generality which allows to use it to solve very different problems. 


\section{Time analysis}
\label{sec:timeanalysis}

\subsection{Proof generation}

All the times shown refer to the time \spass has needed to prove the problem. 
%
Previous parsing and creating the \spass problem has been ignored.



\subsection{Proof checking}

One of the greatest consequences of this method is the possibility to refute the generated proofs to double check they are valid.
%
It has been developed that for each \spass problem there are 3 files generated. The \spass output (storing the information of which axioms had been used and the time), the \spass proof in \spass format and the \spass proof in \gls{tptp} syntax.
%
By generating a tptp proof for each \spass problem we made possible to check this proofs with any other theorem prover as \citetool{vampire} or \citetool{isabelle}.

Another advantage of the generation of this files is the reduced amount of time needed to check the validity of the fine-grained-linked-list implementation. 
%
There is no need to regenerate all the verification conditions and regenerate all the \spass files and let \spass running until it finds the proof for every problem. 
%
One can just run \spass on the generated proofs and will save lot of time.
%
Lets see the amount of time needed to check the proofs in stead of generate them.


\subsection{Comparing times}

In order to use formal verification in real environments, a time analysis is fundamental. 
%
The more time it takes, the more useless formal verification can be.
%
How much time does it takes to generate all the proofs for this linked-list implementation? 
%
And more importantly,  How much time does it takes to check the generated proofs? 

In table \ref{anaylisis::bigtimetable} one can find the summary of the timing according to 4 different times. The first column refers to the time that \leap takes to proof the invariant (obtained from \cite{paperParametrizedInvariants}). 
%
The second column, \textit{Full process}, refers to the time the whole process takes \footnote{The full process is described \doubt{in/at} \ref{ProcessDescription}}. 
%
This is, generating the verification conditions, creating all the \spass problems and letting \spass work to solve each problem.
%
The third column, \textit{Sum of \spass time}, refers to the amount of time that \spass takes to solve all the problems of each invariant.
%
This column shows the real time necessary to generate the proofs, from the already generated files.
%
Finally, the last column shows very important information.
%
The amount of time needed to check that the proofs are correct is less than every other method. 
%
This method reduces significantly the time spent in checking the formal verification of a problem.


\begin{table}[hbtp]
\centering
\begin{tabular}{c|cccc}
Invariant 		& Leap 	& Full process 		& Sum of \spass time 	& Check proofs 	\\
\invPreserve 	& 12:85	&					& 10:56.56				& 0:52.19		\\
\invOrder		& 1:20	&					& 62:32.89				& 7:41.17 		\\
\invLock		& 0:50	& 					& 13:34.0  				& 1:53.94		\\
\invNext 		& 1:76	&					& 100:40.08				& 		\\
\invRegion		& 25:67	& 					& 1:14.68				& 0:19.14		\\
\invDisjoint 	& 0:22 	& 2:13.3 			& 1:17.15 				& 0:26.4		\\
Total: 			& 		& 					& 						&  				\\
\end{tabular}
\caption{Compare of the times.}
\label{anaylsis:bigtimetable}
\end{table}


There are some very relevant issues with the measures of the \textit{Full process} time and the \textit{Sum of \spass time}.

\paragraph{About measuring the full process}
In order to improve performance, all \spass problems are first considered as if they were the simplest. 
%
If it took too much time to \spass (according to a timeout) to find a proof for a problem, then it would be divided.
%
This allows to prove very fast the simple problems, such as the majority of \invDisjoint transitions for example. 
%
When a problem is not so simple (again, according to the timeout), then it is divided and some time has been wasted because the initial attempt to prove the problem is terminated.
%
The value of this timeout is not trivial to be setted.
%
There are transitions which do not need any axioms. 
%
This is caused because they are transitions of the form $(false \to something)$.
%
For this transitions, it is usual that \spass takes less than one second to prove them. 
%
Thus, we could set the timeout to one second. 
%
If a transition is taking more than one seconds, then it may need more axioms and or it should be divided.
%
But we may incur into dividing a problem which does not need to be divided. 
%
Others consecution for transition 33 in \invLock takes 1 second and a half, but does not need to be divided because it is of the form $(false \to something)$.
%
A timeout of 1 second would make \gandalf to divided this transition, but a timeout of 2 seconds second would cause a waste of 1 second in each not simple \spass problem.
%
The timeout had been setted to 100 seconds because it was preferable in order to generate less \spass problems, and consequently less proofs.

The problem explained before acquires more relevance in another context.
%
\spass does not have an expert knowledge about which axioms should be used first because they are relevant and which should not.
%
No arithmetic axiom is needed to prove \invRegion and \spass does not neither need any axiom about the order relation between elements. 
%
There is a subset of axioms for each invariant.
%
Including unnecessary axioms may cause \spass to take more time searching for the proof in a branch where the proof can not be found. 
%
It may not cause any delay because it finds the proof without exploring all the branches.
%
We show an example of this reality.
%
Transition 11 of the \invPreserve takes 23 seconds to \spass when all the axioms are included but it takes 0.44 seconds when only used axioms are included. 
%
This difference has been an important challenge, because when \spass could not find a proof it did not necessary mean that the problem was unsatisfiable. 
%
It could mean that too many unnecessary axiom had been included or that the problem needed to be divided.
%
Thus, the third column shows the real amount of time that \spass has needed to generate the proofs. 
%
This time is not the lowest bound one could get, but as one can see, it is less than the whole process.
%
For the transition mentioned before, \spass takes 0.11 seconds to check that the proof is correct.
