% -*- root: ../main.tex -*-
% -*- dic: en_GB  -*-
\chapter{State of the art\label{sec:estado_del_arte}}

\paragraph{Abstract}

We cover here some of the basics needed to understand the real thesis of this \thisworkm. We will describe some fundamentals of the first order logic (\gls{FOL}), about his undeciability and, of course, how we can use the \gls{FOL} to prove properties of a program. Just two general properties will be covered, such as safety and liveness.

The thesis of this \thisworkm is the definition of a theory for linked list with which we can prove safety. Thus, we will define safety and some examples of how one can prove safety in simpler integer programs.

We include a brief logic of temporal logic needed for lifeness proving, but this topic is not very important in this \thisworkm.

Finally, we try to answer the question of parallelism. We will cover how can we prove safety for programs with multiple threads. We will describe some very important results used in this \thisworkm 
done by \citep{thesisAle}.

\section{The need of formal verification}

As it was shown in the introduction \ref{Motivation} there are some systems in which software errors are totally inadmissible.
%
People developing software for critical systems need an effective way to check the correctness of the software.
%
In addition, they need some guarantee that the compiler they use really generates an executable which does \textbf{exactly} the same.
%
In order to solve this issues there are some tools which have been developed.

\subsection{Solutions}

\subsubsection{Compcert}

School of Computing in the University of Utah claims \ref{CCompilerMotivation}

\textit{We created a tool that generates random C programs, and then spent two and a half years using it to find compiler bugs. So far, we have reported more than 325 previously unknown bugs to compiler developers. Moreover, every compiler that we tested has been found to crash and also to silently generate wrong code when presented with valid inputs.}

So there is a real need of a C verified compiler and that is what \concept{Compcert} is. 
%
Comcpert can compile programs using almost all of the ISO C90 / ANSI C. The project began in 03/2008 and is still under development. Last version was released in 12/2015.

Other compilers \ref{Dargaye-these} are in process to be formally verified.


\subsubsection{VCC}

\gls{VCC} is a tool developed by Microsoft which 

VCC: A Verifier for Concurrent C  http://research.microsoft.com/en-us/projects/vcc/
VCC is sound -- if VCC verifies your program, it really is correct (modulo bugs in VCC itself)

VCC: A Practical System for Verifying Concurrent C. Ernie Cohen, Markus Dahlweid, Mark Hillebrand, Dirk Leinenbach, Micha≈Ç Moskal, Thomas Santen, Wolfram Schulte, Stephan Tobies. 22nd International Conference on Theorem Proving in Higher Order Logics (TPHOLs 2009). (LNCS 5674). http://research.microsoft.com/en-us/um/people/moskal/pdf/tphol2009.pdf (Provides a good overall system description of VCC; the paper to cite for VCC)


\subsubsection{Spin}

http://spinroot.com/spin/what.html

Model checking, embedded C code

Three examples of inspiring applications of Spin in the last few years include the verification of the control algorithms for the new flood control barrier built in the late nineties near Rotterdam in the Netherlands. The verification work was carried out by the Dutch firm CMG (Computer Management Group) in collaboration with the Formal Methods group at the University of Twente.


\subsection{Types of formal verification}

References:

1) Model Checking and Theorem Proving:
a Unified Framework
Sergey Berezin
24th January 2002
CMU-CS-02-100


2) Scalable Techniques for Formal Verification
Sandip Ray
Springer US
978-1-4419-5997-3
Edition 1


\subsubsection{Model checking}


\subsubsection{Theorem prover}

You build your own framework using Issabelle(https://isabelle.in.tum.de/), Spass (ref) or others.


