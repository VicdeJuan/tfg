% -*- root: ../main.tex -*-
\chapter{State of the art\label{sec:estado_del_arte}}

\paragraph{Abstract}

We cover here some of the basics needed to understand the real thesis of this \thisworkm. We will describe some fundamentals of the first order logic (\gls{FOL}), about his undeciability and, of course, how we can use the \gls{FOL} to prove properties of a program. Just two general properties will be covered, such as safety and liveness.

The thesis of this \thisworkm is the definition of a theory for linked list with which we can prove safety. Thus, we will define safety and some examples of how one can prove safety in simpler integer programs.

We include a brief logic of temporal logic needed for lifeness proving, but this topic is not very important in this \thisworkm.

Finally, we try to answer the question of parallelism. We will cover how can we prove safety for programs with multiple threads. We will describe some very important results used in this \thisworkm done by \citep{thesisAle}.

\section{First order logic}

\paragraph{Notation}
\label{def:notation}
We assume the usual way of representing and working with \gls{FOL}, this is
\begin{itemize}
	\item \textbf{Symbols:} $\{),(, \implies, \dimplies, \orcond , \andcond \}$
	\item \textbf{Quantifiers:} $\{\forall, \exists\}$
	\item \textbf{Constants:} $\{\true,\false\}$
	where we define $\true$ as \textit{true} and $\false$ as \textit{false}.
\end{itemize}

One could consider $\exists x(P(x))$  as an abbreviation of $\neg (\forall x(\neg P(x)))$, but for better understanding we would use both quantifiers when needed.
We could also use $(a \orcond b)$ instead of $(\neg a \implies b)$ but, again, for the better understanding those abbreviations will be used.
The same happens with $\true \equiv \neq \false$, but it is clearer when we use both symbols and not just one of them.


\paragraph{Definitions}

We are going to define some very basic concepts, needed and used during the whole \thisworkm.

\begin{defn}[Satisfiability]

A formula $F$ is satisfiable \gls{iff} there exists an interpretation $I$ such that \[I \vDash F\]
\end{defn}

\begin{defn}[Validity]

A formula $F$ is valid \gls{iff} for all interpretations $I$, \[I\vDash F\]
\end{defn}
\label{def:validity}
This 2 concepts are very important and they are very related. $F$ is valid \gls{iff} $\neg F$ is unsatisfiable. 

\begin{defn}[Theory]

A first-order theory is defined by the following components: 
\begin{itemize}
	\item Its \textbf{signature} $\Sigma$ is a set of constant, function and predicate symbols.
	\item Its set of \textbf{axioms} $\axioms$ is a set of \gls{FOL} closed formulae in which only elements from $\Sigma$ appear.
	\subitem The axioms must be 
\end{itemize}
\end{defn}

Now we define some properties a theory may have.

\begin{defn}[Completeness]

	A theory $\Sigma$ is complete \gls{iff} for every closed $\Sigma-$formula $\sigma$ we have \[(\Sigma\vDash \sigma) \orcond (\Sigma\neg\vDash \sigma) \] 
\end{defn}

\begin{defn}[Consistent]

	A theory $\Sigma$ is consistent if there is at least one $\Sigma-$interpretation.

	Another equivalent definition of consistency is:

	A theory $\Sigma$ is consistent if $\Sigma \vDash \false$
\end{defn}

If our theory is not consistent, we can have a formal proof of everything we want to prove.
We can prove that some program is correct and that is not correct, which gives us no information.
In the other hand, completeness may not be possible to achieve because of the incompleteness theorem of Godel.

\begin{itheorem}[Godel's\IS incompleteness theorem]

\textit{Obtained from \citeapos{Godel}}

For any formal effectively generated theory T including basic arithmetical truths and also certain truths about formal provability, if T includes a statement of its own consistency then T is inconsistent.

\end{itheorem}

\textcolor{red}{Conclusions of this theorem}

%From this theorem we see that we can't have a complete and consistent theory while including basic arithmetical truths. Normally, we would have to choose.


\subsection{Decidability}

\begin{defn}[Decidability\IS of theory]

A theory $\Sigma$ is decidable if $\Sigma \vDash F$ is decidable, for every $\Sigma-$formula.

We say a theory in undecidable if it is not decidable.
\end{defn}

\begin{defn}[Decidability\IS of formula]

$F$ a $\Sigma-$formula is decidable if there is an algorith that always terminates with ``yes'' if $F$ is valid in $\Sigma$ ($\Sigma$-valid) or ``no'' if $F$ is not $\Sigma-$valid.
\end{defn}

Decidability is a very desirable property but because \gls{FOL} (the theory with no axioms) is undecidable in general, we may not have decidability in the theory we are working on.

\begin{example}
\index{Theory\IS of equality}
\label{theory:equality}
We are going to define the theory of equality, because it is the simplest first-order theory and it is the only theory included in SPASS.\footnote{We will talk about SPASS in section \ref{def:SPASS}}

The signature of the theory is:

\[\Sigma_e:\{=,a,b,c,...\}\]

and it's axioms are:

\begin{itemize}
	\item[Reflexivity] $\forall x, x=X$
	\item[Symmetry] $\forall x,y x=y \implies y=x$
	\item[Transitivity] $\forall x,y,z x=y \andcond y=z \implies x=z$
	\item[Congruence]
	\subitem[Function] For each function $f$
	\[\forall \gor{x},\gor{y} \left( \bigwedge_{i=1}^n x_i = y_i \right) \implies f(\gor{x}) = f(\gor{y})\]
	\subitem[Predicate] For each function $f$
	\[\forall \gor{x},\gor{y} \left( \bigwedge_{i=1}^n x_i = y_i \right) \implies f(\gor{x}) \dimplies f(\gor{y})\]

	This 2 ``axioms'' are not axioms but an \concept{axiom schema}, because there is one axiom for each function $f$ we want to use.
\end{itemize}

This is a decidable theory as Leopold LÃ¶wenheim proved in 1915 \cite{EqualityIsDecidable}.
\end{example}

\section{Second-order logic (SOL)}

In \gls{SOL} the quantifiers can be used to quantify functions and/or predicates. This gives lot of possibilities to reason about the world and problems but adds lot of complexity.

In the theory of equality (\label{theory:equality}) we could have defined axioms of congruence by:

\[\forall f \left( \forall \gor{x},\gor{y} \left( \bigwedge_{i=1}^n x_i = y_i \right) \implies f(\gor{x}) = f(\gor{y}) \right)\]
\[\forall P \left( \forall \gor{x},\gor{y} \left( \bigwedge_{i=1}^n x_i = y_i \right) \implies P(\gor{x}) \dimplies P(\gor{y}) \right)\]

This is a simpler way of writing but a more complex way of reasoning.

Because it is not possible to reason automatically in theories of second order, we haven't used any second-order logic and we won't get deeper into it.




\section{Program correctness}

We are finally ready to apply this concepts to a real word problem, proving properties of programs.
The remaining task is to define the framework and the conventions we use to prove formally properties of programs.

There are two forms of proving properties. \textbf{Partial correctness} which assert that certain states can not occur during an execution (tipically error states) or \textbf{Total correctness} which assert that some state is eventually reached during any execution. For total correctness we will have to introduce what \textbf{temporal logic} is and its ``quantifiers'' always and eventually.




\subsection{Representing a program in logic}

How can we represent a program as logic.

\subsubsection{Preliminaries (Notation, definition)}

\textcolor{red}{Complete with definitions. What is a transition, what is the pc, etc...}


\subsubsection{Possible instructions}
\begin{description}
\item [Assignments:]
		The transition relation for a variable assignment consists of the 
		update of the program counter for the running thread and the 
		corresponding modification to the variable being assigned.
\[
\begin{array}[t]{p{8em}@{\hspace{6em}}p{\longtablesize}}
	\hline
	Statement & Transition relation \\ \hline\hline
	$\begin{array}[t]{l@{\hspace{0.3em}}c@{\hspace{1em}}l}
		l_1 & : & \mathtt{v := 2} \\
		l_2 & : & \mathtt{\cdots}
	\end{array}$
	&
	$\begin{array}[t]{ll}
		 \pc(T) = l_1 \And
		 \pc'(T) = l_2 \And
		 \mathtt{v}' = 2
	 \end{array}$ \\ 
	 \hline
\end{array}
\]

	\item [Pointer access:]
		Cell fields are accessible through the pointer operator \pointsto.
%
		There are two possible scenarios for the use of pointers, depending on 
		whether the statement accesses or modifies a cell field.
%
		We present now the semantics for both cases.
%
		The first case corresponds to the access of a cell field through an 
		address pointer.
%
		The second case corresponds to the modification of a cell field using 
		an address pointer.
%
		Note how, in the second case, all cells (except the one pointed by 
		$\mathtt{b}$) remain unchanged.
%
		Also, all fields of the cell pointed by $\mathtt{b}$ remain unmodified 
		except for $\mathtt{field_n}$.


\[
\begin{array}[t]{p{8em}@{\hspace{6em}}p{\longtablesize}}
	\hline
	Statement & Transition relation \\ \hline\hline
	$\begin{array}[t]{l@{\hspace{0.3em}}c@{\hspace{1em}}l}
		l_1 & : & \mathtt{v := a \pointsto field} \\ \\
		l_2 & : & \mathtt{\cdots}
	\end{array}$
	&
	$\begin{array}[t]{ll}
		 \pc(T) = l_1 \And
		 \pc'(T) = l_2 \And \\
		 \mathtt{v}' = \heap[\mathtt{a}].\mathtt{field}
	 \end{array}$ \\
	 \hline
\end{array}
\]
	\item [No operation:]
		The no operation statement performs no change at all except from 
		updating the program counter of the executing thread.

\[
\begin{array}[t]{p{8em}@{\hspace{6em}}p{\longtablesize}}
	\hline
	Statement & Transition relation \\ \hline\hline
	$\begin{array}[t]{l@{\hspace{0.3em}}c@{\hspace{1em}}l}
		l_1 & : & \mathtt{\SkipStm} \\
		l_2 & : & \mathtt{\cdots}
	\end{array}$
	&
	$\begin{array}[t]{ll}
		 \pc(T) = l_1 \And
		 \pc'(T) = l_2
	 \end{array}$ \\ \hline
\end{array}
\]	

	\item [Conditionals:]
		We present now the two possible kinds of conditional statements in 
		SPL.
%
		In the first case, if condition $c$ does not hold, the execution 
		proceeds from the statement following the end of the conditional.

		\[
        \begin{array}[t]{p{8em}@{\hspace{6em}}p{\longtablesize}}
				\hline
				Statement & Transition relation \\ \hline\hline
				$\begin{array}[t]{l@{\hspace{0.3em}}c@{\hspace{1em}}l}
					\ell_1 & : & \mathtt{\textbf{if } c \textbf{ then }} \\ \\
					\ell_2 & : & \mathtt{\cdots} \\
						&& \mathtt{\vdots} \\
					\ell_n & : & \mathtt{\textbf{end if}} \\
					\ell_{n+1} & : & \mathtt{\cdots}
				\end{array}$
				&
				$\begin{array}[t]{ll}
					(\pc(T) = \ell_1 \And \;\;\mathtt{c} \And \pc'(T) = \ell_2) \; \Or \\
					(\pc(T) = \ell_1 \And \lnot \mathtt{c} \And \pc'(T) = \ell_{n+1})
				 \end{array}$ \\ \hline
			 \end{array}
		 \]

		In the second case, if condition $c$ does not hold, the execution 
		continues at the first statement in the \textbf{else} section of the 
		conditional statement.

		\[
				\begin{array}[t]{p{8em}@{\hspace{6em}}p{\longtablesize}}
				\hline
				Statement & Transition relation \\ \hline\hline
				$\begin{array}[t]{l@{\hspace{0.3em}}c@{\hspace{1em}}l}
					\ell_1 & : & \mathtt{\textbf{if } c \textbf{ then }} \\ \\
					\ell_2 & : & \mathtt{\cdots} \\
					\mathtt{\vdots} \\
					\ell_n & : & \mathtt{\textbf{else}} \\
					\ell_{n+1} & : & \mathtt{\cdots} \\
					\mathtt{\vdots} \\
					\ell_m & : & \mathtt{\textbf{end if}} \\
					\ell_{m+1} & : & \mathtt{\cdots}
				\end{array}$
				&
				$\begin{array}[t]{ll}
					(\pc(T) = \ell_1 \And \;\;\mathtt{c} \And \pc'(T) = \ell_2) \; \Or \\
					(\pc(T) = \ell_1 \And \lnot \mathtt{c} \And \pc'(T) = \ell_{n+1})
						& \text{for line } \ell_1 \\ \\ \phantom{\vdots} \\

						\pc(T) = \ell_n \And \pc'(T) = \ell_{m+1} & \text{for line } \ell_n
				 \end{array}$ \\ \hline
			\end{array}
		\]

	\item [Loops:]
		We consider the only loop statement available in SPL which executes 
	the statements in the body as long as the loop condition holds.

		\[
				\begin{array}[t]{p{8em}@{\hspace{6em}}p{\longtablesize}}
				\hline
				Statement & Transition relation \\ \hline\hline
				$\begin{array}[t]{l@{\hspace{0.3em}}c@{\hspace{1em}}l}
					\ell_1 & : & \mathtt{\textbf{while } c \textbf{ do }} \\
					\ell_2 & : & \mathtt{\cdots} \\
					\mathtt{\vdots} \\
					\ell_n & : & \mathtt{\textbf{end while}} \\
					\ell_{n+1} & : & \mathtt{\cdots}
				\end{array}$
				&
				$\begin{array}[t]{ll}
						(\pc(T) = \ell_1 \And \;\;\texttt{c} \And \pc'(T) = \ell_2) \; 
						\Or \\
						(\pc(T) = \ell_1 \And \lnot \texttt{c} \And \pc'(T) = 
					\ell_{n+1})
					& \text{for line $\ell_1$} \\ \\
					\pc(T) = \ell_n \And \pc'(T) = \ell_1 &
						\text{for line $\ell_n$}
				 \end{array}$ \\ \hline
			 \end{array}
		\]

			\item [Non deterministic choice:]
		The transition relation for the non-deterministic choice statement can 
		be expressed as follows:

		\[
			\begin{array}[t]{p{8em}@{\hspace{6em}}p{\longtablesize}}
				\hline
				Statement & Transition relation \\ \hline\hline
				$\begin{array}[t]{l@{\hspace{0.3em}}c@{\hspace{1em}}l}
					\ell_1 & : & \mathtt{\Nondet} \\
					\ell_2 & : & \mathtt{\;\;\;\;\;\; \cdots} \\
					\ell_3 & : & \mathtt{\textbf{or } \; \cdots} \\
					\mathtt{\vdots} \\
					\ell_n & : & \mathtt{\textbf{or } \; \cdots} \\
					\ell_{n+1} & : & \mathtt{\NondetEnd} \\
				\end{array}$
				&
				$\begin{array}[t]{ll}
					\pc(T) = \ell_1 \And
					\bigvee\limits_{i = 2..n} \pc'(T) = \ell_i
				 \end{array}$ \\ \hline
			 \end{array}
		\]


	\item [Wait on condition:]
		When waiting on a condition, the program execution does not progress 
		until the condition is satisfied.
	
		\[
			\begin{array}[t]{p{8em}@{\hspace{6em}}p{\longtablesize}}
				\hline
				Statement & Transition relation \\ \hline\hline
				$\begin{array}[t]{l@{\hspace{0.3em}}c@{\hspace{1em}}l}
					\ell_1 & : & \mathtt{\Await c} \\
					\ell_2 & : & \mathtt{\cdots}
				\end{array}$
				&
				$\begin{array}[t]{ll}
					\pc(T) = \ell_1 \And c \And \pc'(T) = \ell_2
				 \end{array}$ \\ \hline
			 \end{array}
		\]

	We can relate to this statement the \fLock and \fUnlock operations used 
	over locks.
%
	Even though these are not SPL statements, as they will be widely used in 
	the rest of the chapters, we describe here the transition relation 
	associated with these two functions.

		\[
			\begin{array}[t]{p{8em}@{\hspace{6em}}p{\longtablesize}}
				\hline
				Statement & Transition relation \\ \hline\hline
				$\begin{array}[t]{l@{\hspace{0.3em}}c@{\hspace{1em}}l}
					\ell_1 & : & \mathtt{\fLock(l)} \\
					\ell_2 & : & \mathtt{\cdots}
				\end{array}$
				&
				$\begin{array}[t]{ll}
					\pc(T) = \ell_1 \And
						\mathtt{l} = \oslash \And
						\mathtt{l}' = T \And \pc'(T) = \ell_2
				 \end{array}$ \\ \hline\hline
				$\begin{array}[t]{l@{\hspace{0.3em}}c@{\hspace{1em}}l}
					\ell_1 & : & \mathtt{\fUnlock(l)} \\
					\ell_2 & : & \mathtt{\cdots}
				\end{array}$
				&
				$\begin{array}[t]{ll}
					\pc(T) = \ell_1 \And
						\mathtt{l}' = \oslash \And \pc'(T) = \ell_2
				 \end{array}$ \\ \hline
			 \end{array}
		\]

\end{description}

\subsection{Partial correctness (Safety)}



\subsection{Total correctness (Lifeness)}

What is proving lifeness, for what we need temporal logic.

\subsubsection{Temporal logic}

Basics on temporal logics

\subsubsection{Lifeness examples}

Now we can give some examples of lifeness examples.


\subsection{Parametrized invariants}

\subsubsection{Finite number of threads}

\subsubsection{Arbitrary number of threads}

