

\todo{No break page on each axiom.}
\subsubsection{Common}

	\begin{axiomdescription}[equality-bt-cell]
		\label{ax::equality_bt_cell}
		\explanation{
			\paragraph{Interpretation:}
			Let c1,c2 be cells. We claim 2 cells are equal if all their fields are equal.
		}
		\begin{formula}
			(c1 = c2 \implies (data(c1) = data(c2) \wedge c1.lockid = c2.lockid \wedge next(c1) = next(c2)))
		\end{formula}
	\end{axiomdescription}

	\begin{axiomdescription}[equality-on-read]
		\label{ax::equality_on_read}
		\explanation{
			\paragraph{Interpretation:}
			Let a,b be addresses and m a memory. Then, reading \doubt{on/in} a memory two equal addresses return the same cell.
		}
		\begin{formula}
			(a = b \implies rd(m,a) = rd(m,b))
		\end{formula}
	\end{axiomdescription}

	\begin{axiomdescription}[next-error--is--null]
		\label{ax::next_error__is__null}
		\explanation{
			\paragraph{Interpretation:} The field \fNext of the \fError \cell is \fNull address.
		}
		\begin{formula}
			next(error) = null
		\end{formula}
	\end{axiomdescription}


\subsubsection{Arithmetic}

	\begin{axiomdescription}[nums-are-different]
		\label{ax::nums_are_different}
		\explanation{
			\paragraph{Interpretation:} All numbers are different one another. \footnote{This axiom is necessary because \spass only includes the equality theory. Thus, 0,1,...,55 are 0-ary functions that could be equal.}
		}
		\begin{formula}
			(0 \neq 1) \andcond (0 \neq 2) \andcond ... \andcond (1\neq 2) \andcond ... (54 \neq 55)
		\end{formula}
	\end{axiomdescription}


\subsubsection{Set theory}

	This axioms are replicated for $\Sigma_{\sSetAddr},\Sigma_{\sSetElem}$ and $\Sigma_{\sSetTid}$.

	\begin{axiomdescription}[union-def]
		\label{ax::union_def}
		\explanation{
			\paragraph{Interpretation:} Let $x$ be a generic, and $se1,se2$ set of generics. Then $x$ belongs to the union of $se1,se2$ \gls{iff} $x$ is in $se1$ or $se2$.
		}
		\begin{formula}
			((in(x,se) \vee in(x,se2)) \dimplies in(x,union(se,se2)))
		\end{formula}
	\end{axiomdescription}

		\begin{axiomdescription}[set-equal]
		\label{ax::set_equal}
		\explanation{
			\paragraph{Interpretation:}
			Two set are equal \gls{iff} there not exists a generic that is in one set but not in the other.
			%
			This axiom is called in literature \cite{yellowbook} \concept{set extensionability}.
		}
		\begin{formula}
			[\nexists \;a\;  (in(a,se2) \dimplies in(a,se1))] \dimplies se1 = se2
		\end{formula}
	\end{axiomdescription}

	\begin{axiomdescription}[union-conmutative]
		\label{ax::union_conmutative}
		\explanation{
			\paragraph{Interpretation:} 
			The union of set is a commutative operation.
		}
		\begin{formula}
			union(se,se2) = union(se2,se)
		\end{formula}
	\end{axiomdescription}

	\begin{axiomdescription}[in-set--def]
		\label{ax::in_set__def}
		\explanation{
			\paragraph{Interpretation:} 
			Let $a,b$ be generics and $se$ a set of generics. If $a$ is not in the set but $b$ is in the set, then $a$ and $b$ can not be equal.
		}
		\begin{formula}
			((\neg\;  in(a,se)) \implies in(b,se) \implies (\neg\;  b = a))
		\end{formula}
	\end{axiomdescription}

	\begin{axiomdescription}[a--in--singl-a]
		\label{ax::a__in__singl_a}
		\explanation{
			\paragraph{Interpretation:}
			Let $se$ be the generic set built from the generic element $a$.
			%
			Then, there are no other address different from $a$ in $se$.
			%
			We call $se = \fSingl(a)$.
		}
		\begin{formula}
			(((\neg\;  a = b) \implies (\neg\;  in(b,\fSingl(a)))) \wedge in(a,\fSingl(a)))
		\end{formula}
	\end{axiomdescription}

	\begin{axiomdescription}[emptySet-is-empty]
		\label{ax::emptySet_is_empty}
		\explanation{
			\paragraph{Interpretation:}
			The generic empty set does not contain any generic.
		}
		\begin{formula}
			(\neg\;  in(a,empty))
		\end{formula}
	\end{axiomdescription}




\subsubsection{Set extension}

%	UNUSED
%	\begin{axiomdescription}[set-exten]
%		\label{ax::set_exten}
%		\explanation{
%			\paragraph{Interpretation:}
%
%		}
%		\begin{formula}
%			se1 = se2 \implies (\forall a in(a,se1) \dimplies in(a,se2))
%		\end{formula}
%	\end{axiomdescription}

	\begin{axiomdescription}[set-exten-inv]
		\label{ax::set_exten_inv}
		\explanation{
			\paragraph{Interpretation:}
			The inverse of set extensionability (described at \ref{ax::set_equal}).
		}
		\begin{formula}
			(\forall a in(a,se1) \dimplies in(a,se2)) \implies se1=se2
		\end{formula}
	\end{axiomdescription}

%	UNUSED
%	\begin{axiomdescription}[SetDiff-def]
%		\label{ax::SetDiff_def}
%		\explanation{
%			\paragraph{Interpretation:}
%			Difference of set definition.
%			%
%			A generic element is not in the difference of any set with $\fSingl(a)$
%		}
%		\begin{formula}
%			((in(x,se) \wedge (\neg\;  in(x,se2))) \dimplies in(x,diff(se,se2)))
%		\end{formula}
%	\end{axiomdescription}

	\begin{axiomdescription}[a-not--in-se-dif-a]
		\label{ax::a_not__in_se_dif_a}
		\explanation{
			\paragraph{Interpretation:}
			A generic element is not in the difference of any set with $\fSingl(a)$
		}
		\begin{formula}
			(in(a,se) \implies (\neg\;  in(a,diff(se,\fSingl(a)))))
		\end{formula}
	\end{axiomdescription}


\subsubsection{Update}

	\begin{axiomdescription}[upd--def--not-null]
		\label{ax::upd__def__not_null}
		\explanation{
			\paragraph{Interpretation:}(Update definition)
			\\
			Let $a$ be an \addr not \fNull, $m$ a \mem and $c$ a \cell.We call $m2$ the result of the \fUpd statement.
			%
			Then, updating the value of $m$ stored \doubt{in} $a$ with any \cell $c$ implies that $c$ is the value returned when reading the stored \doubt{in} $a$ \doubt{at/on/of} the updated memory.
			
		}
		\begin{formula}
			((\neg\;  a = null) \implies upd(m,a,c) = m2 \implies rd(m2,a) = c)
		\end{formula}
	\end{axiomdescription}

	\begin{axiomdescription}[upd--def--one-at-the-time]
		\label{ax::upd__def__one_at_the_time}
		\explanation{
			\paragraph{Interpretation:}
			Lea $a$ be an \addr not \fNull, $m$ a memory. We call $m2$ the result of the \fUpd statement.
			%
			Then, an \fUpd statement of a $a$ only modifies the value stored \doubt{in} $a$ and no other value of $m$
		}
		\begin{formula}
			(((\neg\;  a = null) \wedge (\neg\;  a = b)) \implies upd(m,a,c) = m2 \implies rd(m,b) = rd(m2,b))
		\end{formula}
	\end{axiomdescription}

	\begin{axiomdescription}[rd-mem--def]
		\label{ax::rd_mem__def}
		\explanation{
			\paragraph{Interpretation:}
			The \cell returned when reading the position \fNull of any memory $m$ is the \fError \cell.
		}
		\begin{formula}
			rd(m,null) = error
		\end{formula}
	\end{axiomdescription}


\subsubsection{Element arithmetic}

	\begin{axiomdescription}[less-trans]
		\label{ax::less_trans}
		\explanation{
			\paragraph{Interpretation:}
			Transitivity of the order relation defined \doubt{between/among} \elem.
		}
		\begin{formula}
			((x < y \wedge y < z) \implies x < z)
		\end{formula}
	\end{axiomdescription}

%	UNUSED
%	\begin{axiomdescription}[less-total]
%		\label{ax::less_total}
%		\explanation{
%			\paragraph{Interpretation:}
%			The order relation \doubt{between/among} \elem is total.
%		}
%		\begin{formula}
%			(\neg\;  (x < y \wedge y < x))
%		\end{formula}
%	\end{axiomdescription}

	\begin{axiomdescription}[ls-xy--not-ls-yx]
		\label{ax::ls_xy__not_ls_yx}
		\explanation{
			\paragraph{Interpretation:}
			The order relation \doubt{between/among} \elem is total.

		}
		\begin{formula}
			(x < y \dimplies ((\neg\;  x = y) \wedge (\neg\;  y < x)))
		\end{formula}
	\end{axiomdescription}

	\begin{axiomdescription}[lowest--less-than-highest]
		\label{ax::lowest__less_than_highest}
		\explanation{
			\paragraph{Interpretation:}
			The \fLowest is less than the \fHighest (according to the order relation defined \doubt{between/among?} elements).
		}
		\begin{formula}
			\fLselem(lowestElem,highestElem)
		\end{formula}
	\end{axiomdescription}

	\begin{axiomdescription}[lowestElem--def-tll]
		\label{ax::lowestElem__def_tll}
		\explanation{
			\paragraph{Interpretation:}(Definition of \fLowest)\\
			Any other element is great or equal than the \fLowest.
		}
		\begin{formula}
			\forall \elem(e) (e = lowestElem \vee lowestElem < e)
		\end{formula}
	\end{axiomdescription}

	\begin{axiomdescription}[highestElem--def-tll]
		\label{ax::highestElem__def_tll}
		\explanation{
			\paragraph{Interpretation:}(Definition of \fHighest)\\
			Any other element is less or equal than the \fHighest.
		}
		\begin{formula}
			\forall \elem(e) (e = highestElem \vee e < highestElem)
		\end{formula}
	\end{axiomdescription}




\subsubsection{Addr2set}

	\begin{axiomdescription}[nextreg]
		\label{ax::nextreg}
		\explanation{
			\paragraph{Interpretation:}
		}
		\begin{formula}
			((in(a,se) \wedge se = addr2set(m,b) \wedge c = next(rd(m,a)) \	wedge (\neg\;  a = null))\implies in(c,se))
		\end{formula}
	\end{axiomdescription}

	\begin{axiomdescription}[lock-keeps-addr2set]
		\label{ax::lock_keeps_addr2set}
		\explanation{
			\paragraph{Interpretation:}
			The set of \addr reachable from any \addr $hd$ is preserved after a \fLock statement targeting another (or the same) \addr $a$. 
			%
			This is true because a \fLock statement does not change anything but the thread using the \addr. 
			%
			Even if the \fLock statement targets \fError, the reachable \addr are preserved.
			\todo{Clear enough?}
		}
		\begin{formula}
			(hp_p = upd(hp,a,mkcell(data(rd(hp,a)),next(rd(hp,a)),t)) \implies addr2set(p,hd) = addr2set(hp_p,hd))
		\end{formula}
	\end{axiomdescription}

	\begin{axiomdescription}[addr2set-null-is-singl-null]
		\label{ax::addr2set_null__is__singl_null}
		\explanation{
			\paragraph{Interpretation:}
			The set of \addr reachable from \fNull is the \setaddr with just the \addr \fNull.
			%
			This is true as a consequence of \ref{ax::next_error__is__null}, because the \fNext of \fError is \fNull for every memory.
		}
		\begin{formula}
			addr2set(m,null) = \fSingl(null)
		\end{formula}
	\end{axiomdescription}


\subsubsection{Lock_keeps}

	\begin{axiomdescription}[lock-keeps-heap--data \& lock-keeps-heap--next]
		\label{ax::lock_keeps_heap__data}\label{ax::lock_keeps_heap__next}
		\explanation{
			\paragraph{Interpretation:}
			In the same way a \fLock statement preserve the \setaddr reachable from any \addr $hd$, the same states for some other functions apart from \fAddrToSet.
			%
			A \fLock statement does not change the \fData and \fNext values of a \cell (which is obvious).
		}
		\begin{formula}
			(hp_p = upd(hp,a,mkcell(data(rd(hp,a)),next(rd(hp,	a)),t))) \implies [data(r(hp,a)) = data(rd(hp_p,a)) \andcond next(r(hp,a)) = next(rd(hp_p,a)) ]
		\end{formula}
	\end{axiomdescription}



\subsubsection{Important}

	\begin{axiomdescription}[addr2set-rec-def]
		\label{ax::addr2set_rec_def}
		\explanation{
			\paragraph{Interpretation:}
			Recursive definition of \fAddrToSet.
			%
			As the \fAddrToSet is used to get the reachable \addr from another \addr $a$, it is to expect that the \fAddrToSet of the \fNext of $a$ would be the same \setaddr excluding $a$.
			%
			This definition states that an \addr is reachable from itself.
		}
		\begin{formula}
			addr2set(m,a) = union(\fSingl(a),addr2set(m,next(rd(m,a))))
		\end{formula}
	\end{axiomdescription}

	\begin{axiomdescription}[addr2set-primim]
		\label{ax::addr2set_primim}
		\explanation{
			\paragraph{Interpretation:}
			This axiom is the base of the recursion in the definition of \fAddrToSet. 
		}
		\begin{formula}
			((data(rd(hp,hd)) < data(rd(hp,tl)) \wedge next(rd(hp,hd)) = tl \wedge next(r(hp,tl)) = null) \implies addr2set(hp,hd) = union(union({ hd },{ tl }),\fSingl(\fNull)))
		\end{formula}
	\end{axiomdescription}






	\begin{axiomdescription}[not-in-region--not-change-heap-addr]
		\label{ax::not_in_region__not_change_heap_addr}
		\explanation{
			\paragraph{Interpretation:}
			Let $hp$ be an \addr and $hp$ a \mem. 
			%
			Then, modifying a \mem in an \addr which is not reachable from $hp$ preserves the \setaddr of reachable \addr from $hp$.
		}
		\begin{formula}
			((\neg\;  in(a,addr2set(hp,hd))) \implies addr2set(hp,hd) = addr2set(upd(hp,a,c),hd))
		\end{formula}
	\end{axiomdescription}



	\begin{axiomdescription}[insert--keeps-addr2set]
		\label{ax::insert__keeps_addr2set}
		\explanation{
			\paragraph{Interpretation:}
			This axiom allows to \fUpd a \mem preserving the \fAddrToSe.
			%
			This \fUpd correspond to an insertion in the list.
			\\
			Let $hp$ be the \mem. Let $hd$ be an \addr (the \head of the list would be this \addr).
			%
			We call \reg to the \fAddrToSet reachable from $hd$.
			%
			Let $prev$ and \addr reachable from $hd$ (in the \fAddrToSet of $hp,hd$) and $curr,aux$ two \addr. 
			%
			It is needed that the 3 address ($prev,curr,aux$) are different one another and all of them are not null.
			\\
			If prev points curr, aux points curr, then making prev point to aux has one unique effect on the \reg: aux now is in the \reg so every reachable address before the \fUpd is still reachable and aux is reachable too.
		}
		\begin{formula}
			((reg = addr2set(hp,hd) \wedge union(reg,{ aux }) = reg_p \wedge next(rd(hp,prev)) = curr \wedge (\neg\;  prev = curr) \wedge next(rd(hp,aux)) = curr \wedge (\neg\;  aux = null) \wedge (\neg\;  prev = null) \wedge (\neg\;  curr = null) \wedge in(prev,addr2set(hp,hd)) \wedge hp_p = upd(hp,prev,mkcell(data(rd(hp,prev)),aux,rd(hp,prev).lockid))) \implies reg_p = addr2set(hp_p,hd))
		\end{formula}
	\end{axiomdescription}

	\begin{axiomdescription}[remove--keeps-addr2set]
		\label{ax::remove__keeps_addr2set}
		\explanation{
			\paragraph{Interpretation:}
			In a similar way \ref{ax::insert__keeps_addr2set}, this axioms allows to \fUpd a \mem preserving the \fAddrToSet, but this \fUpd would correspond to a removal in the list.
			\\
			Let $hp$ be the \mem. Let $hd$ be an \addr (the \head of the list would be this \addr).
			%
			We call \reg to the \fAddrToSet reachable from $hd$.
			%
			Let $prev$ and \addr reachable from $hd$ (in the \fAddrToSet of $hp,hd$) and $curr,aux$ two \addr. 
			%
			It is needed that the 3 address ($prev,curr,aux$) are different one another and all of them are not null.
			%
			If prev points curr, aux points curr, then making prev point to aux has one unique effect in the \reg: curr is now not reachable but every \addr reachable before the \fUpd is still reachable.
		}
		\begin{formula}
			((next(rd(hp,curr)) = aux \wedge next(rd(hp,prev)) = curr \wedge (\neg\;  aux = next(rd(hp,prev))) \wedge hp_p = upd(hp,prev,mkcell(data(rd(hp,prev)),aux,rd(hp,prev).lockid)) \wedge (\neg\;  aux = null) \wedge in(curr,addr2set(hp,hd)) \wedge in(null,addr2set(hp,hd)) \wedge in(prev,addr2set(hp,hd))) \implies diff(addr2set(hp,hd),\fSingl(curr)) = addr2set(hp_p,hd))
		\end{formula}
	\end{axiomdescription}


	\begin{axiomdescription}[order-primim]
		\label{ax::order_primim}
		\explanation{
			\paragraph{Interpretation:}
			This axiom is the base of the recursion in the definition of \fOrderlist. 
			%
			Let $hp$ be a \mem, $hd,tl$ two \addr. 
			%
			If the \elem stored in $hp$ at $hd$ is less than the \elem stored in $hp$ at $tl$ and $hd$ point to $tl$, then the list formed by $hd,tl$ is ordered.
		}
		\begin{formula}
			(ls\_elem(data(rd(hp,hd)),data(rd(hp,tl))) \andcond tl = next(rd(hp,hd)) \andcond next(rd(hp,tl)) = nl ) \implies orderlist(hp,hd,tl) 
		\end{formula}
	\end{axiomdescription}

	\begin{axiomdescription}[insert--keeps-orderlist]
		\label{ax::insert__keeps_orderlist}
		\explanation{
			\paragraph{Interpretation:}
			This axioms allows to \fUpd a \mem preserving the \fOrderlist predicate. 
			%
			This update preserve the predicate if certain conditions are satisfied.
			\\
			Let $hp$ be a \mem,$hd,tl$ two \addr which satisfy $\fOrderlist(hp,hd,tl)$ and $tl$ is not \fNull, having $tl$ point to \fNull. Let $prev,aux,curr$ be \addr with ordered elements, i.e. the \elem stored in $hp$ at $prev$ is less than the one at $aux$, which is less than the one at $curr$. In addition, $curr$ is pointed by $aux$ and $prev$.
			\textbf{Then}, updating $hp$ so that $prev$ points to $aux$ preserve \fOrderlist$(hp',hd,tl)$.
		}
		\begin{formula}
			((orderlist(hp,hd,tl) \wedge (\neg\;  tl = null) \wedge next(rd(hp,tl)) = null \wedge data(rd(hp,prev)) < data(rd(hp,aux)) \wedge data(rd(hp,aux)) < data(rd(hp,curr)) \wedge next(rd(hp,aux)) = curr \wedge next(rd(hp,prev)) = curr \wedge hp_p = upd(hp,prev,mkcell(data(rd(hp,prev)),aux,rd(hp,prev).lockid))) \implies orderlist(hp_p,hd,tl))
		\end{formula}
	\end{axiomdescription}

	\begin{axiomdescription}[remove--keeps-orderlist]
		\label{ax::remove__keeps_orderlist}
		\explanation{
			\paragraph{Interpretation:}
			In a similar way \ref{ax::insert__keeps_orderlist}, this axioms allows to \fUpd a \mem preserving the \fOrderlist predicate, but this \fUpd would correspond to a removal in the list. This update preserve the predicate if certain conditions are satisfied.
			\\
			Let $hp$ be a \mem,$hd,tl$ two \addr which satisfy $\fOrderlist(hp,hd,tl)$ and $tl$ points to \fNull. Let $prev,aux,curr$ be \addr which satisfy that $aux$ is pointed by $curr$, which is pointed by $prev$. In addition, $curr,prev,aux$ must be reachable from $hd$.
			\textbf{Then}, updating $hp$ so that $hp$ stores at $prev$ the same cell stored at $aux$ is an action that preserve \fOrderlist for the new $hp$ from $hd$ to $tl$.	

		}
		\begin{formula}
			((aux = next(rd(hp,curr)) \wedge curr = next(rd(hp,prev)) \wedge (\neg\;  aux = null) \wedge null = next(rd(hp,tl)) \wedge (\neg\;  aux = next(rd(hp,prev))) \wedge hp_p = upd(hp,prev,mkcell(data(rd(hp,prev)),aux,rd(hp,prev).lockid)) \wedge in(prev,addr2set(hp,hd)) \wedge in(curr,addr2set(hp,hd)) \wedge in(null,addr2set(hp,hd)) \wedge in(aux,addr2set(hp,hd)) \wedge orderlist(hp,hd,tl)) \implies orderlist(hp_p,hd,tl))
		\end{formula}
	\end{axiomdescription}

%	\begin{axiomdescription}[not-in-region--not-change-heap-list]
%		\label{ax::not_in_region__not_change_heap_list}
%		\explanation{
%			\paragraph{Interpretation:}
%			Let $hp$ be an \addr and $hp$ a \mem. 
%			%
%			Then, modifying a \mem in an \addr which is not reachable from $hp$ preserves the order of the elements in the list.
%		}
%		\begin{formula}
%			((\neg\;  in(a,addr2set(hp,hd))) \implies orderlist(hp,hd) = orderlist(upd(hp,a,c),hd))
%		\end{formula}
%	\end{axiomdescription}




	\begin{axiomdescription}[next-injective--if-ordered]
		\label{ax::next_injective__if_ordered}
		\explanation{
			\paragraph{Interpretation:}
			\fNext is biyective inside an orderlist, i.e., every node of the list has only another node of the list pointing to it.
			\\
			Let $hd,tl$ be \addr, sentinel nodes of an order list in the \mem $hp$.
			%
			As a sentinel node $tl$ points to \fNull.
			%
			Let $a,b,c,d$ be three \addr reachable from $hd$, every \addr different from \fNull and $a,c$ different from $tl$.
			\\
			If $c$ points to $a$, $d$ points to $a$ and $a=b$, \textbf{$c=d$}.
		}
		\begin{formula}
			((orderlist(hp,hd,tl) \wedge in(a,addr2set(hp,hd)) \wedge in(b,addr2set(hp,hd)) \wedge in(c,addr2set(hp,hd)) \wedge in(d,addr2set(hp,hd)) \wedge (\neg\;  tl = null) \wedge null = next(rd(hp,tl)) \wedge (\neg\;  c = null) \wedge (\neg\;  d = null) \wedge (\neg\;  a = null) \wedge (\neg\;  b = null) \wedge (\neg\;  a = tl) \wedge (\neg\;  b = tl) \wedge next(rd(hp,c)) = a \wedge next(rd(hp,d)) = b) \implies a = b \implies c = d)
		\end{formula}
	\end{axiomdescription}

	\begin{axiomdescription}[next-is-not-same--if-ordered]
		\label{ax::next_is_not_same__if_ordered}
		\explanation{
			\paragraph{Interpretation:}
			Let $hd,tl,a$ \addr reachable from $hd$ in the \mem $hp$, every \addr different from \fNull. 
			%
			In addition, $tl$ point to \fNull.
			\textbf{Then} a can not point to itselt.
		}
		\begin{formula}
			((in(a,addr2set(hp,hd)) \wedge in(tl,addr2set(hp,hd)) \wedge (\neg\;  hd = null) \wedge (\neg\;  tl = null) \wedge (\neg\;  a = null) \wedge next(rd(hp,tl)) = null) \implies (\neg\;  next(rd(hp,a)) = a))
		\end{formula}
	\end{axiomdescription}

	\begin{axiomdescription}[just-tail--points--null]
		\label{ax::just_tail__points__null}
		\explanation{
			\paragraph{Interpretation:}
			The only node of the list pointing to \fNull is the sentinel node \tail. 
			%
			One may think that this axiom do not give new any new truth to the axiom set, because of the two previous ones.
			%
			Independently of this axiom being redundant, it provides \spass a performance improvement.
			%
			As it has been stated, this set of axioms is not the minimum set of axioms but is a set sufficient to prove all the invariants.
			\\
			Let $hd,tl$ be \addr reachable from $hd$ in the \mem $hp$, both different from \fNull, and $tl$ pointing to \fNull.
			%
			Let $d$ be a not \fNull \addr which points to \fNull 
		}
		\begin{formula}
			((in(tl,addr2set(hp,hd)) \wedge (\neg\;  hd = null) \wedge (\neg\;  tl = null) \wedge next(rd(hp,tl)) = null \wedge (\neg\;  d = null) \wedge next(rd(hp,d)) = null \wedge in(d,addr2set(hp,hd))) \implies d = tl)
		\end{formula}
	\end{axiomdescription}



	%\vskip 1cm