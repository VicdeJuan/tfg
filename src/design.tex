% -*- root: ../main.tex -*-
\chapter{Design\label{chap:design}}

\paragraph{Abstract} In this chapter we cover the description of the theory used. As we mentioned before is the linked list theory, but one may implement this theory in many different ways. 

Once the theory we are working with is defined, we will expose the goals we intend to prove and which are the intermediate steps to prove the safety of this theory.


\section{Program correctness}


We are finally ready to apply this concepts to a real word problem. In this \thisworkm we apply those concepts to prove some properties of programs.
%
The remaining task is to define the framework and the conventions we use to prove formally properties of programs.

The way of proving correctness is by proving properties. 
%
There are \concept{liveness}, \concept{safety} and \concept{functional} properties. 
%
Safety properties refer, informally, to "bad things never happens". Proving \textit{ variable x is never 0 } is a safety property. 
%
Proving its validity can assure that a division by zero error does never occur. 
%
Whether a program finishes or not is a liveness property and receiving an output for a concrete input is a functional property. 

This properties are written in some logic. Liveness properties need \gls{LTL} but \gls{FOL} is enough to prove safety properties. 
%
As the properties are expressed formally in logic, it is necessary to define a formal representation of a program.


\label{def:SPL}
\input{src/spl}


\subsection{Partial correctness (Safety)}

A function (or the whole program) is \textbf{partially correct} if when the function's precondition is satisfied on entry, its postcondition is satisfied when the function returns (if it ever does).
%
We present the \textbf{inductive assertion method} for proving partial correctness.


Let $\tau$ be the \gls{FOL} property to study. 
%
The procedure is the following:
%
First each function is reduced to a finite set of \gls{FOL} formulae called \concept[Verification condition]{\gls{VC}}.
%
\footnote{This reduction is done with the basic reducing cases we studied in \ref{def:SPL}.}
%
We achieve to prove that $\tau$ is valid in every state of the execution.
%
\textbf{Induction} is the methodology used.
%
First, we assert $\tau$ is valid before the program starts (induction base).
%
Then, we assume $\tau$ in the precondition and prove $\tau'$ valid.



Some examples are studied next to clarify the procedure.

\begin{example}
\input{src/subsrc/exampleFactorial.tex}
\end{example}




\section{Parametrized systems}

The correctness of just one thread executing a program it is an easy problem because it runs sequentiality.
%
Multiple threads executing the same program is a different and more difficult problem to solve.
%
If the number of threads executing is not bounded is another important and difficult step.
%
If the number of threads is bound, one could unroll the formula for all the threads in the problem and try to prove it. 
%
This is why we focus the unbounded case, which is the usual scenario.

We are going to study those cases. 
%
To do so, we need to parametrize the program executed by multiple threads.
%
Typically the threads would be $i$,$j$,$k_0$,$k_1$,... 
%
\subsubsection{Arbitrary number of threads}

For example, the web servers may not have a bound of the number of clients they can accept.
%
Can we prove correctness when an unbounded number of processes are using the same global variabless?

A recent research \citeapos{paperParametrizedInvariants} has proven a very important result. 
%
We will enunciate it and discuss it because it is fundamental for this work. 
%
We will not prove any of the results proven in \citep{paperParametrizedInvariants}.

Before we enunciate the theorem, we need some previous concepts.
%
We need to extend the concept of support to parametrized formulas.


\begin{defn}[Support]
  Let $\psi$, $A$ and $B$ be parametrized formulas, and let $S$ be the
  set of possible substitutions from the set of parametrized variables in $\psi$ ($\Var(\psi)$) into the set of parametrized variables of $(A\Into B)$ ($\Var(A\Into B)$).
%
  We say that $\psi$ supports $(A\Into B)$, whenever
%
  \[ \big( (\bigwedge_{\sigma\in S} \sigma(\psi)\big) \andcond A\big) \Into B \hspace{4em} \text{is valid} \]
%
  We use $\psi\supports(A\Into B)$ as a short notation for
  $\big((\bigwedge_{\sigma\in S} \sigma(\psi)) \andcond A\big) \Into B$.  
\end{defn}

Note that if $S'\subseteq S$ is a subset of the substitutions, and 
%
  \[ \big( (\bigwedge_{\sigma\in S'} \sigma(\psi)\big) \andcond A\big) \Into B \hspace{4em} \text{is valid} \]
%
then
%
  \[ \big( (\bigwedge_{\sigma\in S} \sigma(\psi)\big) \andcond A\big) \Into B \hspace{4em} \text{is also valid} \]
%
  Essentially, if one is successful proving the validity of a formula obtained by removing some of the conjuncts from the antecedent, the validity of the full formula holds.
%
  Hence, in practice, it is enough to consider only some of the partial substitutions to show that a support formula is valid.


\begin{itheorem}[Bound an arbitrary number of threads]
	Let $\varphi$ be a thread-parametrized formula, where $\overline{k}=\Var(\varphi)$. 
	%
	Let $\tau$ be a transition of $P$ and $\ThetaParam$ the initial condition.

	To show that $P$ satisfies $\Always\varphi$:
	\hspace{-1em}
	\[ 
		\begin{array}{r@{\;\;}lr@{\;}@{\;}cl@{\hspace{1em}}l}
			\Premise{S1}. & & \ThetaParam(\overline{k}) &\supports & \varphi & \\

			\Premise{S2}. & \varphi \supports & \tau^{(i)} &\Into& \varphi'  & \text{forall $\tau$ and all $i\in \overline{k}$}\\
			\Premise{S3}. & \varphi\supports & \big(\bigwedge\limits_{x\in\Var(\varphi)} j\neq x \andcond \tau^{(j)} &\Into& \varphi' \big)& \text{forall $\tau$ and one fresh $j\notin\overline{k}$}\\ \hline
			& \multicolumn{4}{c}{\hspace{3em} \Always \varphi} &
		\end{array}
	\]
\label{thm:biggest}
\end{itheorem}



Using this powerful result, we have reduced an arbitrary number of processes sharing the same variables to a finite number of threads sharing the variable. 
%
The proof of this result can be found in \citeapos{paperParametrizedInvariants}.
%
We will refer to $\Premise{S1}$ as \concept{initiation} because it depends on the initial condition.
%
$\Premise{S2}$ will be referred as \concept{self-consecution} because it depends on the execution of the one of the threads in the formula.
%
Finally, $\Premise{S3}$ will be referred as \concept{others-consecution} because it depends on the execution of threads which do not appear in the formula. 


\begin{example}
Threads sharing and array. Each thread has an index. How to assure no other thread writes in my index?
\end{example}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Linked list theory}

\subsection{Description}

In order to work with a linked list in a context with multiple thread using the same list 
there are two approach. 
%
A thread could lock the entire list, work with it and then release it. 
%
There could be some optimizations in this approach, such as a writer-reader system.
%
However, this is extremely \doubt{unefficient} although it could more secure in terms of preventing deadlocks.
%
The other approach is locking and unlocking each node of the list, so multiple threads can work simultaneously using the same list while they don't need to use the same node.
%
This approach takes us to a lock-coupling linked list.



\begin{defn}[Lock-coupling linked list]
A lock-coupling concurrent list~\cite{herlihy08art,vafeiadis06proving} is 
a concurrent data type that implements a set by maintaining in the heap an 
ordered single-linked list with non-repeating elements.
%
Each node in the list is protected by a lock which guarantees that a 
single thread can access a list node at the same time.
%
\end{defn}

The way a thread iterates over the list is the following.
%
The thread acquires the lock of the node
that it visits and after that tries to acquire the next node.
The first lock is only released the lock of the
second node has been successfully acquired.
%
This technique of protecting cells with locks (instead of protecting
the whole data-structure with a single coarse-grain lock) is known as
\concept{fine-grained locking}.


The nodes of a concurrent lock-coupling list are instances of the following 
\ListNode class:
%
\[
  \begin{array}{ll}
	  \class & \Node  \;\{\\
	  		&\begin{array}{l}
				Elem \:\;\; data; \;\\
				Addr \:\;\; next; \;\\
				Lock \:\;\; lock; \;
			\end{array}\\
		&\}
  \end{array}
\]
%
Where:
\begin{itemize}
		\item \fData: the value stored in the node, This value is used to keep 
			the list ordered.
		\item \fNext: a pointer that stores the address of the next node in 
			the list.
		\item \fLock: which contains the lock protecting the node.
\end{itemize}

We assume that the operating system provides the atomic operations \fLock 
and \fUnlock. 

\concept{Ghost variable} are variables which are not properly in the program but are added to 
achieve the verification needed.
Our implementation of concurrent lock-coupling lists has 4 global variables.
%
Two of them are global addresses \head and \tail, and the other two are ghost global variables \region and \elements:
%
\begin{center}
	\includegraphics[scale=\figscale]{graphics/_lists_classes}
\end{center}
%
The declared global program variables are:

\head, an address, which points to the first node of the list which has the lowest possible value ($-\infty$).

\tail, an address, which points to the last node of the list  which has the lowest possible value ($+\infty$).

\region, a set of addresses, which is used to keep track of the portion of the heap whose cells form the list.

\elements, a set of elements, which represents the collection of elements stored in the list.

In figure \ref{fig:listcode} we present the program we are going to use, written in \gls{SPL}, with . We can see there are three procedures, \Search, \Insert and \Remove. 

We consider \head and \tail sentinel nodes which are neither removed nor 
modified and we assume that the list is initialized with \head and \tail 
already set.
%
The set \region is initialized containing solely the addresses of \head 
and \tail.
%
Similarly, the set \elements is initialized containing only the elements 
initially stored at the nodes pointed by \head and \tail.
%
There is also a function \concept{havocListElem}() which returns a random element. 


\begin{figure}[!htbp]
		\myframe{\includegraphics[scale=0.4]{graphics/_listcode}}
		\caption{ Concurrent lock-coupling lists implementation.}
		\label{fig:listcode}
\end{figure}


\subsection{TL3}

\emph{Theory of Linked Lists with Locks} \TLLpL, is the theory we use for describing linked-list heap memory layout.
%
\TLLpL is a multi-sorted first-order theory.
%
It is multi-sorted because it has multiple types for its variables (address, element,...).
%
It is a first-order theory because only variables are quantifiable, as \gls{FOL}.

In this section \TLLpL is defined with the purpose we have. 
%
A more complete and formal definition of \TLLpL can be found in \citeapos{paperAle} and \citep[6.2]{thesisAle}.


\TLLpL is a compound of theories. Informally,  
$\Sigma_{cells}$ models \emph{cells}, structures containing an element (data), an address (pointer) and a lock owner, which represents a node in a linked list.
%
$\Sigma_{mem}$ models the memory.
%
$\Sigma_{setaddr}$ models sets of addresses.
%
$\Sigma_{settid}$ models sets of thread identifiers.
%
$\Sigma_{setelem}$ models sets of elements.
%
$\Sigma_{reach}$ models finite sequences of non-repeating addresses,
to represent acyclic paths in memory.
%
Finally, $\Sigma_{Bridge}$ is a \emph{bridge theory} containing auxiliary
functions, for example, that allow to map paths of addresses to set of 
addresses, or to obtain the set of addresses reachable from a given 
address following a chain of \fNext fields.

\todo{Complete with TL3}
