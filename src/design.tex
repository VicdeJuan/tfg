% -*- root: ../main.tex -*-
\chapter{Design\label{chap:design}}

\paragraph{Abstract} In this chapter we cover the description of the theory used. As we mentioned before is the linked list theory, but one may implement this theory in many different ways. 

Once the theory we are working with is defined, we will expose the goals we intend to prove and which are the intermediate steps to prove the safety of this theory.

\section{Linked list theory}

\subsection{Description}

\begin{defn}[Lock-coupling linked list]
A lock-coupling concurrent list~\cite{herlihy08art,vafeiadis06proving} is 
a concurrent data type that implements a set by maintaining in the heap an 
ordered single-linked list with non-repeating elements.
%
Each node in the list is protected by a lock which guarantees that a 
single thread can access a list node at the same time.
%
\end{defn}

When a thread traverses the list, it acquires the lock of the node
that it visits, and only releases this lock after the lock of the
successor node has been successfully acquired.
%
This technique of protecting cells with locks (instead of protecting
the whole data-structure with a single coarse-grain lock) is known as
\emph{fine-grained locking}.

%
Nodes of a concurrent lock-coupling list are instances of the following 
\ListNode class:
%
\[
  \begin{array}{ll}
	  \class & \Node  \;\{\\
	  		&\begin{array}{l}
				Elem \:\;\; data; \;\\
				Addr \:\;\; next; \;\\
				Lock \:\;\; lock; \;
			\end{array}\\
		&\}
  \end{array}
\]
%
Where:
\begin{itemize}
		\item \fData, the value stored in the node, which is also used to keep 
			the list ordered;
		\item \fNext, a pointer that stores the address of the next node in 
			the list; and
		\item \fLock, which contains the lock protecting the node.
\end{itemize}

We assume that the operating system provides the atomic operations \fLock 
and \fUnlock. 

\concept{Ghost variable} are variables which are not properly in the program but are added to 
achieve the verification needed.

Our implementation of concurrent lock-coupling lists has 4 global variables.
%
Two of them are
global addresses \head and \tail, and the other two are ghost global variables \region 
and \elements:
%
\begin{center}
	\includegraphics[scale=\figscale]{graphics/_lists_classes}
\end{center}
%
The declared global program variables are:
%
\begin{enumerate}
		\item A variable \head, of type address, which points to the 
			first node of the list which has the lowest possible value ($-\infty$).
		\item A variable \tail, of type address, which points to the 
			last node of the list  which has the lowest possible value ($+\infty$).
		\item A ghost variable \region, of type set of addresses, which is 
			used to keep track of the portion of the heap whose cells form the 
			list.
		\item A ghost variable \elements, of type set of elements, which 
			represents the collection of elements stored in the list.
\end{enumerate}


We consider \head and \tail sentinel nodes which are neither removed nor 
modified and we assume that the list is initialized with \head and \tail 
already set.
%
The set \region is initialized containing solely the addresses of \head 
and \tail.
%
Similarly, the set \elements is initialized containing only the elements 
initially stored at the nodes pointed by \head and \tail.
%
There is also a function \concept{havocListElem}() which returns a random element. 

In figure \ref{fig:listcode} we present the program we are going to use, written in \gls{SPL}, with the assume. We can see there are three procedures, \Search, \Insert and \Remove. 

\begin{figure}[!htbp]
		\myframe{\includegraphics[scale=0.4]{graphics/_listcode}}
		\caption{ Concurrent lock-coupling lists implementation.}
		\label{fig:listcode}
\end{figure}


\subsection{TL3}
\todo{This section should be removed?}

\emph{Theory of Linked Lists with Locks} \TLLpL, is the theory we use for describing linked-list heap memory layout.
%
\TLLpL is a multi-sorted first-order theory.

In this section \TLLpL is defined with the purpose we have. 
%
A more complete definition of \TLLpL can be found in \citeapos{paperAle} and \citep[6.2]{thesisAle}.

\paragraph{Theories: } The theories used in \TLLlP, informally: 
$\Sigma_{cells}$ models \emph{cells}, 
	structures containing an element (data), an address (pointer) and a lock owner,
		which represents a node in a linked list.
%
$\Sigma_{mem}$ models the memory.
%
$\Sigma_{setaddr}$ models sets of addresses.
%
$\Sigma_{settid}$ models sets of thread identifiers.
%
$\Sigma_{setelem}$ models sets of elements.
%
$\Sigma_{reach}$ models finite sequences of non-repeating addresses,
to represent acyclic paths in memory.
%
Finally, $\Sigma_{Bridge}$ is a \emph{bridge theory} containing auxiliary
functions, for example, that allow to map paths of addresses to set of 
addresses, or to obtain the set of addresses reachable from a given 
address following a chain of \fNext fields.



\subsection{Invariants of the implementation}

\subsubsection{Goal}

We achieve to prove that this implementation of a linked list always preserves the list structure. 
%
There are some conditions to assure that a set of nodes is a list.
%
An order has to be preserved, \head and \tail must keep the properties of its definition. 
%
We gather all the necessary conditions in the formula:


\[
	\begin{align*}
	  	\invPreserve & \overset{\mbox{def}}{=} \formulaFullListReducedBody
	\end{align*}
\]

(L1) establishes that \fNull is to \region and that \region is
exactly the set of addresses reachable in the \heap starting from
\head, which ensures that the list is not circular.
%
(L2) and (L3) express some sanity properties of the sentinel nodes
\head and \tail.
%
(L4) establishes that \elements is the set of elements in cells 
referenced by addresses in \region, except for the element at the cell 
pointed by \fNull.
%
Finally, (L5) express the fact that the list is ordered.

We claim \invPreserve is an invariant of this implementation and the proof can be found later in \ref{proof:Preserve}. 
%
Although this may seem easy, human ingenuity makes it hard. 
%
As \citeapos{tempVerifLinkedList} has proven, this is not and inductive invariant. 
%
We need others invariants as support.

\todo{List of invariants}

