% -*- root: ../main.tex -*-
\chapter{Development\label{sec:develpment}}

\paragraph{Abstract} 
%In this chapter, the practical work will be exposed. Until now, just the theoretical fundamentals of the subject have been defined.

%Here we will expose the rigorous methodology used to mathematically prove our goals. To achieve that, some tools have been developed, and they will be described too.

%Finally, we will cover the axioms we needed to prove all the intermediate and the final steps. The completeness of this theory will be discussed at the end of the chapter. 

\section{Methodology used}

\subsection{Process, tools used \& tools developed}

\subsubsection{Spass}

\spass (\citeapos{spass}) is an automated theorem prover for first-order logic with equality. 
%
\spass receives a \gls{FOL} formula and tries to prove it.
% 
Running SPASS on such a formula results in the final output \textit{SPASS beiseite: Proof found.} if the formula is valid or  \textit{SPASS beiseite: Completion found.} if the formula is not valid.
Because validity in first-order logic is undecidable, SPASS may run forever without producing any final result.
%
This last comment is a very important issue because some proofs has taken hours and one could not know if \spass will eventually stop or run forever.
%
As a curiosity, the longest time \spass was left running was 82 hours and it stopped because a proof was found.

At appendix \ref{spass:syntax_file} an example of a complete \spass file can be found.

\subsubsection{Leap}

\leap is a tool for the verification of concurrent data types and parametrized systems composed by an unbounded number of threads that manipulate infinite data.

Leap receives as input a concurrent program description and a specification and automatically generates a finite set of verification conditions which are then discharged to specialized decision procedures. 
%
The validity of all discharged verification conditions implies that the program executed by any number of threads satisfies the specification. 
%
Currently, Leap includes not only decision procedures for integers and Booleans, but it also implements specific theories for heap memory layouts such as linked-lists and skiplists.

\leap uses decision procedures, based in model searching while \spass does automatic reasoning. 



\subsubsection{\gandalf}

\gandalf is the implemented tool to prove \gls{VC} with \spass. 
%
The process of converting the \leap-generated verification condition to \spass syntax, splitting different conjunctions in different files, calling \spass to try to prove and process and storing the results has been automatized basically in python combined with bash.
Plus, \spass reads prefix syntax while leap has prefix and infix syntax.

Additionally, \gandalf does some reduction of the formulas so \spass can finish in a reasonable time.
%
This is needed because \spass does not have information nor tactics about which axiom should be used first.



\subsubsection{Process}

Once the tools have been described, we can explain the process. 
%
The process followed is shown in the figure \ref{fig:process}


\begin{figure}
\input{tikz/processgraph}
\caption{Process graph}
\label{fig:process}
\end{figure}

The first step consists on translate the program given to its \gls{VC}. 
%
This is done by \leap. 
%
In the case of this problem, \leap generates at least 2 \gls{VC} for each transition of the program. 
%
The first \gls{VC} corresponds to the self-consecution \gls{VC} and the second corresponds to the others-consecution \gls{VC}. The initial transition is also generated.
%
This is done 6 times, one for each existing invariant of the problem (\ref{invariants}).

Once the \gls{VC} have been generated, the goal is to prove all of them using \spass. 
%
As \spass syntax (\cite{spasssyntax}) it is not \leap syntax (\cite{leapsyntax}) some parsing is needed. 
%
For example, \spass uses prefix notation while \leap uses infix notation for binary functions.
%
In order to solve this, it was necessary to learn \ocaml using \citeapos{ocamlbook}.
%
\leap was forked so it could write the \gls{VC} in prefix notation.
%
Some other \leap functionalities had to be changed to make compatible \leap output with \spass input.

In addition, one \spass problem has to be created for each \gls{VC}. 
%
The axiom list for each problem is determined as an argument. 
%
This is explained further in section \ref{sec:axiomgraph}.

Because of \spass lack of tactics and the size of the axiom list, some very easy transitions could take too much time.
%
Transitions which can be proven using \pc reasoning \spass could take minutes. 
%
In order to improve \spass performance, the problem is divided.

Let $\varphi$ be the \gls{VC} to prove. For the explanation, 
	\[
		\varphi \equiv \pc(i) = l_j \to \head \not = \tail
	\]
While proving the \gls{VC} for the thread $i$, $\pc(i)$ has a value which may be $l_j$ or not. 
%
In both cases, resolution can be applied to prove equivalently
	\[
		\psi \equiv \head \not = \tail
	\]
This resolution can be applied in self-consecution and in others-consecution. 
%
This resolution step is done by \gandalf. 
%
Some other obvious resolution is done, such as $\top \andcond \top \equiv \top$ and other tautologies.

Now \spass can prove a simpler problem and it takes \doubt{little time}.
%
To assure this is equivalent, another \spass problem is generated. 
%
This \spass problem aims to prove $\psi \to \varphi$.
%
In order to prove $\varphi$, modus ponens is used:
\[
	\begin{array}{l}
		\psi\\
		\psi \to \varphi\\\hline
		\varphi
	\end{array}
\]

Despite 2 \spass problems have to be solved instead of 1, in \ref{sec:timeanalysis} the reader can see the benefits of applying this \doubt{workaround}.
%
And this is a logic consequence. $\varphi$ is a complex problem for \spass. 
%
However, $\psi$ is a much simpler problem because it does not include any reasoning about the program counter. 
% How to express:
%%%%    I didn't check that is tautologic in every transition, but i am pretty sure it is.
In addition, the problem $\psi \to \varphi$ is tautologic in most of the transitions because it adds conjectures in the precedent of an implication, which can't make invalid a valid formula.
%
Plus, the list of axioms needed to prove this problem is small in compare to the axiom list needed to prove the original problem.


$\psi$ problem will be called \textbf{\reducedProblem} and $\psi \to \varphi$ will be called \textbf{\smallToBig}. $\varphi$ problem will be called \textbf{\originalProblem}

$\psi$ \spass problem should not have $\pc$ involved. How can the $\pc$ be removed while proving others-consecution?
%
Again, more \spass problems are generated. 
%
In this case, 55 new problems are generated and modus ponens is used:
\[
	\begin{array}{l}
		\psi_1\\
		\psi_2\\
		\vdots\\
		\psi_{55}\\
		(\bigwedge_i \psi_i) \to \varphi\\\hline
		\varphi
	\end{array}
\]
%%%%    I didn't check that is tautologic in every transition, but i am pretty sure it is.
In this case, the \spass problem $(\bigwedge_i \psi_i) \to \varphi$ is tautologic most of the time, but \spass takes much more time than before because of the problem size.




\subsection{Auxiliary tools}
\subsubsection{\ocaml - parser}
All the process described before needs an axiom list. 
%
Getting the axioms needed to prove all the transitions was the most difficult work. 
%
More than once, an axiom list was written and all the \gls{VC} proven. In the process of checking the generated proofs to verify they were correct, inconsistencies were found. 
%
This inconsistencies were always consequence of false axioms. 
%
Because of human ingenuity, it was very difficult to assure absolute validity of the axioms.\footnote{Axioms should be universally valid (not just valid in \TLLpL theory) so they could be used for other theories \leap work with.}
%
In order to solve this, it was decided that every axiom must be validated with \leap. 
%
This procedure does not assure absolute validity to the axioms but helped a lot to find incomplete axioms.

As there are several axioms, a parser was implemented to automatize the parsing files from \spass syntax to \leap. 
%
The parser was implemented in \ocaml so \ocaml skills could be improved. Additionally, \citetool{ocamllex} and \citetool{ocamlyacc}, \ocaml variants of the \mbox{C} tools studied during the bachelor degree (\textit{Proyecto de Aut√≥matas y Lenguajes}) have been used to implement the parsing.
%
The \doubt{functionality of translating} from \spass syntax to \LaTeX\; syntax has also been included to generate the axiom list \ref{ax::fulllist}



\section{Linked list}
%
We achieve to prove that the implementation proposed at \ref{fig:listcode} of a linked list always preserves the list structure. 
%
There are some conditions to assure that a set of nodes is a list.
%
An order has to be preserved, \head and \tail must keep the properties of its definition. 
%
We gather all the necessary conditions in the formula \ref{inv:list}:


	\begin{align}
	  	\invPreserve & \overset{\mbox{def}}{=} \formulaFullListReducedBody
	  	\label{inv:list}
	\end{align}

(L1) establishes that \fNull is to \region and that \region is
exactly the set of addresses reachable in the \heap starting from
\head, which ensures that the list is not circular.
%
(L2) and (L3) express some sanity properties of the sentinel nodes
\head and \tail.
%
(L4) establishes that \elements is the set of elements in cells 
referenced by addresses in \region, except for the element at the cell 
pointed by \fNull.
%
Finally, (L5) express the fact that the list is ordered.

We claim \invPreserve is an invariant of this implementation and the proof can be found later in \ref{proof:Preserve}. 
%
Although this may seem easy, human ingenuity makes it hard. 
%
As \citeapos{tempVerifLinkedList} has proven, this is not an inductive invariant. 
%
We need others invariants as support.

\subsubsection{Invariants of the implementation}
\label{invariants}
As these are not principal but auxiliary invariants, we cover a brief description of them.
%
This auxiliary invariants are needed to prove \invPreserve and 
%
the full formula of each invariant is at \ref{appendix::inv:full}.
%
%
%
%
\paragraph{Disjoint:}
This invariants provides the information needed when inserting a new element.
%
Two different malloc return 2 different addresses, so there is not possible to insert the same address twice in the list.
%
\paragraph{Region:}
This invariants refers to the information related to which addresses are in \region var, i.e., which addresses are reachable from \head.
%
\paragraph{Locks:}
This invariants refers to the information provided by the locks. 
%
The \fLock acquired at line $l_i$ is not unlocked until line $l_{i+j}$, so at lines $l_{k}\; k\in(i,i+j)$ the \fLock should be locked.
%
This is a very important invariant because it assures that concurrency is possible and it is well mplemented.
%
\paragraph{Order:}
This invariants refers to the information related to the order of the list. 
%
\paragraph{Nexts:}
This invariants refers to the information provided by \fNext statements. 
%
If at $l_i$, $\curr := \prev\to\fNext()$,  $\curr$ still has $\prev$ value until a new assignment to $\curr$ is done.
%
This invariant assures provides the information of these relation between addresses.

\subsubsection{Dependencies between invariants}
\invOrder is the only inductive invariant. 
%
The rest of the auxiliary invariants need also some other invariants to prove them.
%
In figure \ref{fig:proofgraph} the graph of dependencies is shown.
%
As it is shown, \invDisjoint invariant is not directly needed to proof \invPreserve, but it is needed as support to proof both \invNext and \invRegion. 

\begin{center}
\includegraphics[scale=0.7]{graphics/proofgraph_lists.pdf}
\label{fig:proofgraph}
\end{center}

One could think that it is not sound to prove \invLock using \invRegion as support and prove \invRegion using \invLock as support.
%
\todo{\;\;Why\;it\;is\;not \text{   cheating?}}
