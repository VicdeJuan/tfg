% -*- root: ../main.tex -*-
\chapter{Development\label{sec:develpment}}

\paragraph{Abstract} 

In this chapter, we describe the practical work.
%
Until now, we just have defined the theoretical foundations.

Here we will expose the rigorous methodology used to mathematically perform our verification.
%
To achieve our goals, we have developed some tools which are described here too.

We will end the chapter defining precisely the goal and the logic formulas needed to prove valid in order to claim that the program is verified.

\section{Methodology Used}

\subsection{Process, Tools Used and Tools Developed}

\subsubsection{Spass}

\spass \cite{spass} is an automated theorem prover for first-order logic with equality. 
%
\spass receives a \gls{FOL} formula and tries to prove it valid.
% 
Running SPASS on such a formula results in the final output “\textit{SPASS beiseite: Proof found.}” if the formula is valid or  “\textit{SPASS beiseite: Completion found.}” if the formula is not valid.
%
Because validity in first-order logic is undecidable, SPASS may run forever without producing any final result.
%
This last comment is a very important issue because some proofs have taken hours and one could not know for sure if \spass would eventually stop or run forever.
%
As a curiosity, the longest time \spass was left running was 82 hours and it stopped because a proof was found.

%At appendix \ref{spass:syntax_file} an example of a complete \spass file can be found.

\subsubsection{Leap}

\leap is a tool for the verification of concurrent data types and parametrized systems executed by an unbounded number of threads which manipulate mutable shared data in the heap.

Leap receives as input a concurrent program description and a specification and automatically generates a finite set of verification conditions which are then discharged to specialized decision procedures. 
%
The validity of all discharged verification conditions implies that the program executed by any number of threads satisfies the specification. 
%
Currently, Leap includes not only decision procedures for integers and Booleans, but it also implements specific theories for heap memory layouts such as linked-lists and skiplists.


\subsubsection{\gandalf}

\gandalf is a tool implemented  as part of this project to aid \spass proving \gls{VC}. 
%
\gandalf implements the process of converting the VCs generated by \leap to \spass syntax, splitting different conjunctions in different files, calling \spass to try to prove and process and storing the results has been automatized basically in python combined with bash scripts.
%
Additionally, \spass reads prefix syntax while \leap uses prefix and infix syntax.

In addition, \gandalf does some reduction of the formulas so \spass can finish in a reasonable time.
%
This is needed because \spass does not use any information or tactics to decide which axiom should be used first.


\subsubsection{Process of Tool Cooperation}

\label{ProcessDescription}
We describe now the way in which the tools cooperate.
%
The process followed is shown in Fig. \ref{fig:process}. 


\begin{figure}
\input{tikz/processgraph}
\caption{Process graph.}
\label{fig:process}
\end{figure}

The first step consists on translating the program into \gls{VC}. 
%
This is done by \leap. 
%
In the case of verifying single linked list, \leap generates at least 2 \gls{VC} for each transition of the program. 
%
The first \gls{VC} corresponds to self-consecution, and the second corresponds to others-consecution.
%
The initial transition is also generated.
%
The process is repeated 6 times, one for each candidate invariant of the problem (\ref{invariants}).

Once the \gls{VC}s have been generated, the goal is to prove all of them using \spass. 
%
As the syntax of \spass (\cite{spasssyntax}) is not \leap syntax some parsing is needed. 
%
For example, \spass uses prefix notation  \leap uses infix notation for binary functions.
%
In order to solve this, it was necessary to learn \ocaml using \cite{ocamlbook}.
%
\leap was forked so it could write the \gls{VC}s in prefix notation.
%
Some other \leap functionalities had to be changed to make \leap output compatible with \spass input.

In addition, one \spass problem has to be created for each \gls{VC}. 
%
The axiom list for each problem is determined as an argument because not every \spass problem needs the same axioms. 
%
This is explained further in section \ref{sec:axiomgraph}.

Because of \spass lacks of tactics and the relatively large size of the axiom list, some very easy proofs could take a long time.
%
For transitions which can be proven using very simple reasoning using \pc s,\spass could take minutes. 
%
In order to improve \spass performance, we decided to divide the problem upfront.

Let $\varphi$ be the \gls{VC} to prove. Consider for example the following \gls{VC}
	\[
		\varphi : \;\;\;\;\; \pc(i) = l_j \to \head \not = \tail
	\]
While proving the \gls{VC} for the thread $i$, $\pc(i)$ has a value which may be $l_j$ or not. 
%
In both cases, resolution can be applied to prove equivalently
	\[
		\psi : \;\;\;\;\; \head \not = \tail
	\]
This resolution can be applied in self-consecution and in others-consecution. 
%
This resolution step is done by \gandalf. 
%
Some other obvious resolution is also performance at this stage, such as $\top \andcond \top \equiv \top$ and other tautologies.

Now \spass can prove a simpler problem requiring much less time.
%
To make sure that both problem are equivalent and that the conversion was sound, we generate another \spass problem. 
%
This \spass problem aims to prove $\psi \to \varphi$.
%
In order to prove $\varphi$, modus ponens is used:
\[
	\begin{array}{l}
		\psi\\
		\psi \to \varphi\\\hline
		\varphi
	\end{array}
\]

Even though two \spass problems have to be solved instead of one, in \ref{sec:timeanalysis} the reader can see the benefits of applying this method.
%
The reason is that $\varphi$ is a complex problem for \spass. 
%
However, $\psi$ is a much simpler problem because it does not include any reasoning about program counters. 
% How to express:
%%%%    I didn't check that is tautologic in every transition, but i am pretty sure it is.
In addition, the problem $\psi \to \varphi$ is tautologic in most of the transitions because it adds conjectures in the antecedent of an implication, which cannot make invalid a valid formula.
%
Plus, the list of axioms needed to prove $\psi$ is smaller where compared to the axiom list needed to prove the original problem.


The generated problem $\psi$ will be called the \textbf{\reducedProblem} and $(\psi \to \varphi)$ will be called the \textbf{\smallToBig}. $\varphi$ problem will be called the \textbf{\originalProblem}

The \reducedProblem  should not have any $\pc$ involved. How can the $\pc$ be removed while proving others-consecution?
%
Again, more \spass problems are generated. 
%
In this case, 55 new problems are generated and using modus ponens:
\[
	\begin{array}{l}
		\psi_1\\
		\psi_2\\
		\vdots\\
		\psi_{55}\\
		(\bigwedge_i \psi_i) \to \varphi\\\hline
		\varphi
	\end{array}
\]
%%%%    I didn't check that is tautologic in every transition, but i am pretty sure it is.
In this case again, the \spass problem $(\bigwedge_i \psi_i) \to \varphi$ is tautologic most of the time, but \spass takes much more time than before because of the problem size.




\subsection{Auxiliary Tools}
\subsubsection{\ocaml - parser}
All the process described above require an axiom list. 
%
Getting the axioms needed to prove all the transitions was the most difficult work. 
%
Typically, we provided \spass with an axiom list with which all \gls{VC}s were proven. In the process of checking the generated proofs and verify they were correct, we found some inconsistencies. 
%
This inconsistencies were always consequence of incorrect axioms. 
%
Because of human ingenuity, it was very difficult to ensure absolute validity of the axioms.\footnote{Axioms should be universally valid (not just valid in \TLLpL theory) so they could be used for other theories that \leap can work with.}
%
In order to solve this, we decided to validate every axiom using \leap. 
%
This procedure does not assure absolute validity to the axioms but helped a lot to find incomplete axioms.

As there are several axioms, a parser was implemented to automatize the parsing files from \spass syntax to \leap. 
%
The parser was implemented in \ocaml so \ocaml skills could be improved. Additionally, \citetool{ocamllex} and \citetool{ocamlyacc}, \ocaml variants of the \mbox{C} tools studied during the bachelor degree (\textit{Proyecto de Autómatas y Lenguajes}) have been used to implement the parser.
%
The functionality of translating from \spass syntax to \LaTeX\; syntax has also been included to generate the axiom list \ref{ax::fulllist}



\section{Linked list}
%
We manage to prove that the implementation proposed at \ref{fig:listcode} of a concurrent lock coupling linked-list always preserves the list structure. 
%
There are some conditions to assure that a set of nodes is a list.
%
An order has to be preserved, \head and \tail must keep the properties of its definition. 
%
We gather all the necessary conditions in formula (\ref{inv:list}):


	\begin{align}
	  	\invPreserve & \overset{\mbox{def}}{=} \formulaFullListReducedBody
	  	\label{inv:list}
	\end{align}

(L1) establishes that \fNull is in \region and that \region is
exactly the set of addresses reachable in the \heap starting from
\head, which ensures that the list is not circular.
%
(L2) and (L3) express some sanity properties of the sentinel nodes
\head and \tail.
%
Finally, (L4) express the fact that the list is ordered.

We claim that the formula \invPreserve is an invariant of this implementation. The full proof can be found later in \ref{proof:Preserve}. 
%
Although this may seem easy, human ingenuity makes it hard. 
%
In \citeapos{tempVerifLinkedList} the authors whoen that \invPreserve is not an inductive invariant. 
%
We need others invariants as support.

\subsubsection{Invariants of the implementation}
\label{invariants}
As these are not principal but auxiliary invariants, we just provided here a brief description of them.
%
These auxiliary invariants are needed to prove \invPreserve and 
%
a full description of each formula appear in \ref{appendix::inv:full}.
%
%
%
%
\paragraph{\invDisjoint:}
This invariants provides the information needed when inserting a new element.
%
Two different \fMalloc invocations return two different addresses, so there is not possible to insert the same address twice in the list.
%
\paragraph{\invRegion:}
These invariants refers to the information about to which addresses are in the ghost variable \region var, that is, which addresses are reachable from \head.
%
\paragraph{\invLock:}
These invariants refer to the information provided by the locks. 
%
The \fLock acquired at line $l_i$ is not unlocked until line $l_{i+j}$, so at lines $l_{k}\; k\in(i,i+j)$ the \fLock should be locked by the running thread.
%
This is a very important invariant because it assures that concurrent access are safe and therefore it is well implemented.
%
\paragraph{\invOrder:}
These invariants refer to the information related to the order of the list. 
%
\paragraph{\invNext:}
These invariants refer to the information provided by \fNext statements. 
%
If at $l_i$, $\curr := \prev\to\fNext()$, is executed $\curr$ still has the value $\prev$ until a new assignment to $\curr$ is done.
%
This invariant encodes the information about the relation between addresses.

\subsubsection{Dependencies between invariants}
The only inductive invariant is \invOrder. 
%
The rest of the auxiliary invariants need some other invariants to prove them.
%
In figure \ref{fig:proofgraph} the graph of dependencies is shown.
%
As it is shown, the invariant \invDisjoint is not directly needed to proof \invPreserve, but it is needed as support to proof both \invNext and \invRegion. 

\begin{center}
\includegraphics[scale=0.5]{graphics/proofgraph_lists.pdf}
\label{fig:proofgraph}
\end{center}


One could think that it is not sound to prove \invLock using \invRegion as support and prove \invRegion using \invLock as support. 
%
This apparent circularity is an important point for the proofs.
%
We claim this apparent circularity is not a circularity and it is sound.

Let $\varphi$,$\psi$ be two invariant candidates of a program such that the initiation step is valid for both of them.
%
It is sound using $\varphi$ as support for proving $\psi$ and using $\psi$ as support for proving $\varphi$. More formally, we show it as a lemma with its proof.

\begin{lemma}
Let $\varphi$ and $\psi$ be two candidate to invariants of a program. 


Let $\theta$ be the initial condition and let initiation hold for $\varphi$ and $\psi$.
\[\theta \to (\varphi \andcond \psi)\]

Let $\psi$ be a support of $\varphi$ and $\varphi$ be a support of $\psi$. Then, for every transition $\tau_j$ in the program we have:
%
\[\forall j, \tau_j \andcond \varphi \andcond \psi \to \psi'\]
\[\forall j, \tau_j \andcond \varphi \andcond \psi \to \varphi'\]

\textbf{Then}, $\psi$ and $\varphi$ are invariants.
\end{lemma}

\begin{proof}
Proof by contradiction: Let $\psi$ not be an invariant.
%
Thus, there is at least one state $j$ in which $\psi_j$ does not hold.
%
Lets take $j$ as the first counterexample.
%
By hypothesis, $\psi(0)$ (initiation) is valid, so $j>0$.

Lets take the transition $\tau_{j-1}$.
%
As $j$ is the first counterexample, in state ${j-1}$ both $\psi,\varphi$ hold.
%
Thus, by hypothesis, $\psi_{j-1} \andcond \tau_{j-1} \andcond \varphi_{j-1} \to \psi_j$ is valid.
%
This is a contradiction because $\psi_j$ was not valid.
\end{proof}



